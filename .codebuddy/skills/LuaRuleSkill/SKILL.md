---
name: lua-rule-skill
description: Enforces and explains the project Lua coding standard. Invoke when user asks to write, refactor, review, or format Lua code according to Lua代码规范.md.
---

# Lua-Rule-Skill - Lua 代码规范约束与评审

**核心目标**: 当用户编写/修改/评审 Lua 代码时，严格以本仓库的 [Lua代码规范.md](./Lua代码规范.md) 作为唯一约束来源，输出可执行的整改建议；若用户明确要求“直接修改代码”，则在修改后给出逐条对照说明。

**重要说明**:
- **约束来源唯一**：所有规则仅来自 `Lua代码规范.md`，不额外引入外部风格或个人偏好
- **先理解再约束**：对代码意图做最小必要理解，避免“为了改格式而改逻辑”
- **默认不改代码**：未收到“请直接改/给我改好”的明确指令时，只输出问题清单与建议改法

---

## Stage 0: 环境检测与规范加载（Environment Detection & Spec Loading）

**目标**: 明确本 Skill 的约束来源、输出形式与执行边界

**执行时机**: 所有其他 Stage 之前，必须首先执行

**伪代码流程**:

```
// ========== Stage 0: 环境检测与规范加载 ==========

// 0. 加载 Lua 代码规范（作为唯一约束来源）
加载 Lua代码规范.md 获取 规则集合

// 1. 校验输入
IF 用户未提供 Lua 代码片段 或 Lua 文件路径 THEN
    输出 "需要用户提供 Lua 代码片段或文件路径，才能进行规范检查"
    RETURN
END IF

// 2. 确认用户意图
IF 用户要求 "直接修改" 或 "给出改完后的代码" THEN
    执行模式 = "rewrite"
ELSE
    执行模式 = "review"
END IF

// 3. 建立输出约定
输出约定 = {
    问题清单: 必须,
    规则引用: 必须,
    修改建议: 必须,
    修改后的代码: 仅 rewrite 模式
}

传递:
    - 规则集合
    - 执行模式
    - 输出约定
```

---

## Stage 1: 代码结构扫描与信息抽取（Code Scanning & Extraction）

**目标**: 在不改变代码语义的前提下，收集与规范检查相关的信息（函数、模块、表结构、命名、空白等）

**执行时机**: Stage 0 完成之后

**伪代码流程**:

```
// ========== Stage 1: 代码结构扫描与信息抽取 ==========

输入 = 获取用户输入(代码片段 或 文件路径)

// 1. 预处理
代码文本 = 读取输入为文本(Input)

IF 代码文本 为空 THEN
    输出 "读取失败或内容为空"
    RETURN
END IF

// 2. 基础扫描（不做语义级推断）
扫描结果 = {
    模块返回形式: 未知,
    全局变量疑似: [],
    函数定义列表: [],
    表构造器列表: [],
    可疑缩进与空白: [],
    运算符空格问题: [],
    逗号空格问题: [],
    分号用法问题: [],
    命名问题: [],
    注释规范问题: [],
    字符串拼接建议点: [],
    table 操作风险点: []
}

// 3. 识别模块返回
IF 代码包含 "return" 且 return 后为 table 或 function THEN
    扫描结果.模块返回形式 = "return_table_or_function"
END IF

传递:
    - 代码文本
    - 扫描结果
```

---

## Stage 2: 按规则逐项检查（Rule-by-Rule Validation）

**目标**: 基于 `Lua代码规范.md` 逐条产出“问题 -> 规则引用 -> 修复建议”，并尽量可定位到行

**执行时机**: Stage 1 完成之后

**伪代码流程**:

```
// ========== Stage 2: 按规则逐项检查 ==========

问题列表 = []

// 1. 函数调用括号（必须）
IF 发现 "foo \"param\"" 或 "bar { ... }" 形式 THEN
    添加到 问题列表:
        类型 = "函数规范"
        严重级别 = "必须"
        规则 = "函数调用不能省略括号"
        建议 = "改为 foo(\"param\") / bar({ ... })"
END IF

// 2. 全局变量（必须）
IF 扫描结果.全局变量疑似 不为空 THEN
    FOR EACH item IN 扫描结果.全局变量疑似 DO
        添加到 问题列表:
            类型 = "变量规范"
            严重级别 = "必须"
            规则 = "避免滥用全局变量或全局函数，尽量用 local"
            建议 = "将 " + item + " 改为 local，或封装进模块表返回"
    END FOR
END IF

// 3. 空白与运算符（必须）
FOR EACH issue IN 扫描结果.运算符空格问题 DO
    添加到 问题列表:
        类型 = "空白规范"
        严重级别 = "必须"
        规则 = "二元操作符前后应当加空格"
        建议 = "在对应操作符两侧补齐空格"
END FOR

// 4. 逗号空格（必须）
FOR EACH issue IN 扫描结果.逗号空格问题 DO
    添加到 问题列表:
        类型 = "空白规范"
        严重级别 = "必须"
        规则 = "逗号之前避免空格，逗号之后需要空格"
        建议 = "统一为: { 1, 2, 3 }"
END FOR

// 5. 分号（必须）
IF 扫描结果.分号用法问题 不为空 THEN
    添加到 问题列表:
        类型 = "逗号和分号"
        严重级别 = "必须"
        规则 = "不要通过 ; 对语句分行，一行只能有一个语句"
        建议 = "移除 ; 并拆分为多行"
END IF

// 6. 字符串拼接（推荐/必须）
IF 发现 循环中字符串拼接 可能导致大量临时字符串 THEN
    添加到 问题列表:
        类型 = "编码技巧"
        严重级别 = "必须"
        规则 = "循环拼接字符串场景使用 table.concat"
        建议 = "改为 sub_str[#sub_str + 1] = ... ; res = table.concat(sub_str)"
END IF

// 7. table 使用（必须）
IF 发现 array 下标从 0 开始 THEN
    添加到 问题列表:
        类型 = "表的操作"
        严重级别 = "必须"
        规则 = "禁止显式指定 array 下标从 0 开始"
        建议 = "将起始下标调整为 1，并同步修正遍历逻辑"
END IF

传递:
    - 问题列表
```

---

## Stage 3: 生成整改方案与可选改写（Fix Plan & Optional Rewrite）

**目标**: 将问题列表组织为“最小改动的整改方案”；若为 `rewrite` 模式，则输出改写后的 Lua 代码

**执行时机**: Stage 2 完成之后

**伪代码流程**:

```
// ========== Stage 3: 生成整改方案与可选改写 ==========

IF 问题列表 为空 THEN
    输出 "未发现违反 Lua代码规范.md 的问题"
    RETURN
END IF

// 1. 输出问题清单（按严重级别排序：必须 > 推荐）
输出 问题列表

// 2. 生成整改步骤
整改步骤 = []
FOR EACH issue IN 问题列表 DO
    添加到 整改步骤:
        - "定位: " + issue.类型
        - "规则: " + issue.规则
        - "建议: " + issue.建议
END FOR

输出 整改步骤

// 3. 可选：改写代码
IF 执行模式 == "rewrite" THEN
    改写后代码 = 基于(代码文本, 整改步骤) 生成最小改动版本

    // 安全约束：不改变语义
    IF 改写后代码 改变了业务逻辑 或 删除了关键分支 THEN
        输出 "拒绝改写：检测到可能改变语义的修改"
        RETURN
    END IF

    输出 改写后代码
END IF
```

---

## 使用示例（Usage Examples）

### 示例 A（单目标）: 评审一段 Lua 代码是否符合规范

**用户输入**:
```
帮我检查这段 Lua 代码是否符合规范，并指出必须修复的问题
```

**执行流程**:
1. Stage 0: 加载 `Lua代码规范.md`，确认执行模式为 `review`
2. Stage 1: 扫描代码结构与高风险点
3. Stage 2: 按规则输出问题列表（带规则引用与建议）
4. Stage 3: 汇总整改步骤（不改写代码）

### 示例 B（批量/全量）: 让助手直接改写并输出修复后的代码

**用户输入**:
```
请直接把这段 Lua 代码按项目规范改好，并说明每个修改对应哪条规范
```

**执行流程**:
1. Stage 0: 加载 `Lua代码规范.md`，确认执行模式为 `rewrite`
2. Stage 1: 扫描代码结构与问题定位
3. Stage 2: 生成问题列表与规则引用
4. Stage 3: 输出最小改动的改写代码 + 修改对照说明

---

## 注意事项（Important Notes / Constraints / Edge cases）

- **必须**：所有结论均需能在 `Lua代码规范.md` 中找到对应条目（可用标题/原句引用）
- **必须**：不擅自引入新的模块结构、公共库或全局依赖
- **必须**：默认优先“早返回”与“降低嵌套”，但不能改变原始业务分支语义
- **推荐**：输出中区分“必须（Mandatory）”与“推荐（Preferable）”两类问题
- **推荐**：当用户代码涉及 `self:GetParentActor()` 相关规则时，明确提示该项目额外规则要求
